#ifndef GEOMETRY_BASE_HALO
#define GEOMETRY_BASE_HALO
//include utils
#include "../utils/base.halo"
#include <fstream>
#include <iostream>

#define MAX_NX 100
#define MAX_NY 100
#define BOUNDARY_CELL 10
#define SIDE 1.0
#define PI 3.14

//maximum number of cell the code can handle at this point a 500x500
//you will need to hard code the above values to change this behaviour
//
//        |-------|-------|-------|
//        |       |       |       |
//        |i-1,j+1| i,j+1 |i+1,j+1|
//        |       |       |       |
//        |-------|-------|-------|
//        |       |       |       |
//        | i-1,j |  i,j  | i+1,j |
//        |       |       |       |
//        |-------|-------|-------|
//        |       |       |       |
//        |i-1,j-1| i,j-1 |i+1,j-1|
//        |       |       |       |
//        |-------|-------|-------|
//
//[i,j]th cell will exchange fluxes with [i,j-1], [i+1,j], [i,j+1], [i-1,j]
//starting from bottom and moving in counter clockwise direction
//we will use them in this sequence wherever required
//
//[i,j]th cell will have corner points given by index [i,j], [i+1,j], [i+1,j+1], [i,j+1]
//starting from left bottom in counter clockwise direction
//we wil preserve the same sequence, werever required
class Domain{
public:
  //initializing variable corresponding to x, y coordiated for cell and corner points
  double x[MAX_NX+1][MAX_NY+1] = {};
  double y[MAX_NX+1][MAX_NY+1] = {};
  int boundary_cell = BOUNDARY_CELL;
  int Nx, Ny;
  //state properties of cell
  //Euler in 2D uses only 4 while ideal MHD uses 8
  //declaration of state in utils/base.halo
  scell cell[MAX_NX][MAX_NY] = {};

  //set the size of the domain
  void set_domain_size(int iNx, int iNy){Nx=iNx;Ny=iNy;}

  //setup functions
  virtual void calc_coordinates(void);
  void set_vertex(int i, int j);
  void calc_centroid(int i, int j);
  void calc_normal(int i, int j);
  void init(int i, int j);
  void write_grid_file(void);
  void write_domain_file(void);
  void setup(void);

}; 
 


//default calc coordinates makes a square domain of size 1
void Domain::calc_coordinates(void){
  double dx = SIDE/Nx;
  double dy = SIDE/Ny;
  for(int i=0;i<Nx+1;i++){
    for(int j=0;j<Ny+1;j++){
      x[i][j] = i*dx;
      y[i][j] = j*dy;
    }
  }    
}

void Domain::set_vertex(int i, int j){
  cell[i][j].vertex[0].x = x[i][j];
  cell[i][j].vertex[0].y = y[i][j];

  cell[i][j].vertex[1].x = x[i+1][j];
  cell[i][j].vertex[1].y = y[i+1][j];

  cell[i][j].vertex[2].x = x[i+1][j+1];
  cell[i][j].vertex[2].y = y[i+1][j+1];

  cell[i][j].vertex[3].x = x[i][j+1];
  cell[i][j].vertex[3].y = y[i][j+1];
}

void Domain::calc_centroid(int i, int j){
  point sum{0.0,0.0};
  for(int k=0;k<4;k++){
    sum.x += cell[i][j].vertex[k].x;
    sum.y += cell[i][j].vertex[k].y;
  }
  cell[i][j].centroid.x = 0.25*sum.x;
  cell[i][j].centroid.y = 0.25*sum.y;
}

void Domain::calc_normal(int i, int j){
  point tn;
  double mag;
  for(int k=0;k<4;k++){
    switch(k){
    case 0:
      tn.x = (y[i+1][j] - y[i][j]);
      tn.y = -(x[i+1][j] - x[i][j]);
      break;
    case 1:
      tn.x = (y[i+1][j+1] - y[i+1][j]);
      tn.y = -(x[i+1][j+1] - x[i+1][j]);
      break;
    case 2:
      tn.x = (y[i][j+1] - y[i+1][j+1]);
      tn.y = -(x[i][j+1] - x[i+1][j+1]);
      break;
    case 3:
      tn.x = (y[i][j] - y[i][j+1]);
      tn.y = -(x[i][j] - x[i][j+1]);
      break;
    };
    mag = magnitute(tn);
    cell[i][j].normal[k].x = tn.x/mag;
    cell[i][j].normal[k].y = tn.y/mag;
  }
}


void Domain::init(int i, int j){
      cell[i][j].state.u = 1.111111111111111111;
      cell[i][j].state.v = 1.0;
      cell[i][j].state.p = 1.0;
}

void Domain::write_grid_file(void){
  std::ofstream grid("grid.dat");
  grid.precision(15);
  for(int i=0;i<Nx+1;i++){
    for(int j=0;j<Ny+1;j++){
      grid<<x[i][j]<<" "<<y[i][j]<<"\n";
    }
  }
  grid.close();
}

void Domain::write_domain_file(void){
  std::ofstream domain("domain.dat");
  domain.precision(15);
  for(int i=0;i<Nx;i++){
    for(int j=0;j<Ny;j++){
      domain<<" "<<cell[i][j].centroid.x<<" "<<cell[i][j].centroid.y<<" ";
      for(int k=0;k<4;k++){
	domain<<cell[i][j].normal[k].x<<" "<<cell[i][j].normal[k].y<<" ";
      }
      for(int k=0;k<10;k++){
	domain<<cell[i][j].state.u<<" ";
      }
      domain<<"\n";
    }
  }
  domain.close();
}



void Domain::setup(void){
  calc_coordinates();
  for(int i=0;i<Nx;i++){
    for(int j=0;j<Ny;j++){
      set_vertex(i, j);
      calc_centroid(i, j);
      calc_normal(i, j);
      init(i, j);
    }
  }
  write_grid_file();
  write_domain_file();
}

#endif
