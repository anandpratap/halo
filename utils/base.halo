#ifndef UTILS_BASE_HALO
#define UTILS_BASE_HALO
#define GAMMA 1.4

namespace utils{
  int iindex(int boundary){
    switch(boundary){
    case 0:
      return 0;
    case 1:
      return 1;
    case 2:
      return 0;
    case 3:
      return -1;
    default:
    return -100000;
    }
    
  }
  int jindex(int boundary){
    switch(boundary){
    case 0:
      return -1;
    case 1:
      return 0;
    case 2:
      return 1;
    case 3:
      return 0;
    default:
      return -100000;
      
    }
  }
 
  void copy(double *source, double *dest){
    for(int i=0;i<10;i++){
      dest[i] = source[i];
    }
  }
  

  void convert(cvariables a, vector b){
    b[0] = a.rho;
    b[1] = a.rhou;
    b[2] = a.rhov;
    b[3] = a.rhow;
    b[4] = a.Bx;
    b[5] = a.By;
    b[6] = a.Bz;
    b[7] = a.E;
  } 
  
  void convert(vector a, cvariables b){
    b.rho = a[0];
    b.rhou = a[1];
    b.rhov = a[2];
    b.rhow = a[3];
    b.Bx = a[4];
    b.By = a[5];
    b.Bz = a[6];
    b.E = a[7];
  }
  

}

namespace math{
  double sqr(double x){
    return x*x;
  }
  
   
  int sgn(double x){
    return x >=0 ?1:-1;  
  }
  
  //Modulus function
  double mod(double x){
    return x < 0 ? -x:x;
  }

  double average(double a, double b){
    return 0.5*(a + b);
  }
  

  void mult(matrix A, vector b, vector c){
    for(int i=0;i<8;i++){
      c[i] = 0.0;
      for(int j=0;j<8;j++){
	c[i] += A[i][j]*b[j];
      }
    }
}
  
  void mult(vector b, matrix A, vector c){
    for(int i=0;i<8;i++){
      c[i] = 0.0;
      for(int j=0;j<8;j++){
      c[i] += A[j][i]*b[j];
      }
    }
  }
}
 
#endif
