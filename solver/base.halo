#ifndef SOLVER_BASE_HALO
#define SOLVER_BASE_HALO

//include other modules
#include "../utils/include.halo"
#include "../geometry/include.halo"
#include "../include.halo"
#include "../defn.halo"

class Solver{
  
public:
  int Nx, Ny;
  int Nb;
  double t, tf, dt;
  Domain domain;
  int btype[4];
  variables freestream[4];
  void setup(Domain domain);
  void setBoundary(int bottom, int right, int top, int left);
  void setTime(double t);
  void setFreestream(int boundary, variables freestream);
  void applyBoundaryConditions(void);
  void calcFlux(int i, int j);
  void loopDomain(void);
  void advanceTime(void);
  void loopTime(void);
  void calcDt(void);
  void checkGarbage(void);
};


void Solver::setup(Domain idomain){
  std::cout<<"Solver Setup";
  domain = idomain;
  Nb = domain.boundary_cell;
  Nx = domain.Nx;
  Ny = domain.Ny;
  checkGarbage();
  std::cout<<"setup done";
}

void Solver::setBoundary(int bottom, int right, int top, int left){
  btype[0] = bottom;
  btype[1] = right;
  btype[2] = top;
  btype[3] = left;
}

void Solver::setTime(double t){
  tf = t;
}

void Solver::setFreestream(int boundary, variables ifreestream){
  freestream[boundary] = ifreestream;
}

// btype 
// 0 -> free stream
// 1 -> outflow
// 2 -> reflective

void Solver::applyBoundaryConditions(void){
  // bottom boundary
  for(int i=0; i< Nx; i++){
    for(int j=0; j< Nb; j++){
      variables bstate{0.0};
      switch(btype[0]){
      case 0:
	bstate = freestream[0];
	break;
      case 1:
	bstate = domain.cell[i][Nb].state;
	break;
      }
      domain.cell[i][j].state = bstate;
    }
  }

  // right boundary
  for(int i=Nx-Nb; i< Nx; i++){
    for(int j=0; j< Ny; j++){
      variables bstate{0.0};
      switch(btype[1]){
      case 0:
	bstate = freestream[1];
	break;
      case 1:
	bstate = domain.cell[Nx-Nb-1][j].state;
	break;
      }
      domain.cell[i][j].state = bstate;
    }
  }

  // top boundary
  for(int i=0; i< Nx; i++){
    for(int j=Ny-Nb; j< Ny; j++){
      variables bstate{0.0};
      switch(btype[2]){
      case 0:
	bstate = freestream[2];
	domain.cell[i][j].state = bstate;
	break;
      case 1:
	bstate = domain.cell[i][Ny-Nb-1].state;
	break;
	
      }
      domain.cell[i][j].state = bstate;
    }
  }

  // left boundary
  for(int i=0; i< Nb; i++){
    for(int j=0; j< Ny; j++){
      variables bstate{0.0};
      switch(btype[3]){
      case 0:
	bstate = freestream[3];
	domain.cell[i][j].state = bstate;
	break;
      case 1:
	bstate = domain.cell[Nb][j].state;
	break;
	
      }
      domain.cell[i][j].state = bstate;
    }
  }

}

void Solver::checkGarbage(void){
  for(int i=0;i<Nx;i++){
    for(int j=0;j<Ny;j++){
      scell c = domain.cell[i][j];
      assert(c.state.rho != 0);
      assert(c.state.p != 0);
    }
  }
}

void Solver::calcFlux(int i, int j){
  cvariables UL, UR, U_avg;
  vector VL, VR;
  scell cL, cR;
  vector uL, uR;
  vector fL, fR, f;                      /// left and right flux in characteristic form
  cL = domain.cell[i][j];         /// Left Cell
  UL = mhd::conservative(cL.state);    /// Converting the states into conservative 
  mhd::flux(UL, cL.normal[1], f);
  utils::convert(UL, uL);

  for(int boundary=0; boundary<4; boundary++){
    eigensystem sysl = mhd::calc(UL, cL.normal[boundary]);
    cR = domain.cell[i+iindex(boundary)][j+jindex(boundary)];         /// Right Cell
    UR = mhd::conservative(cR.state);
    U_avg = average(UL, UR, 1);     /// Taking average of states
    /// average function in utility/mhd.halo
    eigensystem sys = mhd::calc(U_avg, cL.normal[boundary]);      /// Calculating the eigensystems
    /// definition of eigensystem in utility/defn.halo
    eigensystem sysr = mhd::calc(UR, cL.normal[boundary]);
    math::mult(sys.L, uL, VL);
    math::mult(sys.L, f, fL);
    utils::convert(UR, uR);
    math::mult(sys.L, uR, VR);
    mhd::flux(UR, cR.normal[3], f);
    math::mult(sys.L, f, fR);
    
    //Applying the Roe's Flux Formulation:-
    math::mult(sys.R, VL, uL);
    math::mult(sys.R, VR, uR);
    vector FL, FR;
    math::mult(sys.R, fL, FL);
    math::mult(sys.R, fR, FR);
    if(DEBUG){
      for(int l=0; l<8;l++){
	for(int m=0;m<8;m++){
	  //std::cout<<sys.L[l][m];
	}
      }
      for(int tmptmp=0;tmptmp<8;tmptmp++){
	//assert(uL[tmptmp] != 0);
      }
    }

    vector rest = {0.0};
    for (int k = 0; k < 8; k++){
      double ws = 0;
      vector l, r;
      utils::copy(sys.direction[k].leigenvector, l);
      utils::copy(sys.direction[k].reigenvector, r);

      vector U_diff;
      for (int m = 0; m < 8; m++){
	U_diff[m] = uR[m] - uL[m];
      }
      for (int m = 0; m < 8; m++){
	ws += l[m] * U_diff[m];
      }
      
      double fix, delta;
      double evalue = sys.direction[k].eigenvalue;
      double stuff = 4*(sysr.direction[k].eigenvalue - sysl.direction[k].eigenvalue);
      if (stuff > SMALL){
	delta = stuff;
      }else{
	delta = SMALL;
      }
      if (mod(evalue) >= (delta/2)){
	fix = mod(evalue);
      }else{
	fix = (evalue*evalue / delta) + (delta / 4);
      }
      
      ws *= fix;
      
      for (int m = 0; m < 8; m++){
	rest[m] += ws * r[m];
      }
      
    }
    vector flu;
    for (int k = 0; k < 8; k++){
      flu[k] = (FL[k] + FR[k]) / 2 - rest[k]/2;
    }
    
    //std::cout<<cL.facelength[boundary]<<"\n";
    for (int k = 0; k < 8; k++)	{
      cL.F[boundary][k] = flu[k]*cL.facelength[boundary];
    } 
  }
  
  for(int m=0; m < 8; m++){
    cL.residue[m] = 0.0;
    for(int k=0; k < 4; k++){
      cL.residue[m] += cL.F[k][m];
    }
    cL.residue[m] /= cL.area;
    if(DEBUG){
      std::cout<<cL.residue[m]<<"\n";
      //assert(cL.residue[m] != 0);
    }
  }
}

void Solver::loopDomain(void){
  for(int i = 1; i < Nx-1; i++){
    for(int j = 1; j < Ny-1; j++){
      calcFlux(i, j);
    }
  }
}

void Solver::calcDt(void){
  dt = 0.0000001;
}

void Solver::advanceTime(void){
  vector U;
  cvariables UU;
  scell c;
  for(int i = 0; i < Nx; i++){
    for(int j = 0; j < Ny; j++){
      c = domain.cell[i][j];
      convert(mhd::conservative(c.state),U);
      for(int k=0; k<8; k++){
	U[k] += c.residue[k]*dt;
      }
      convert(U, UU);
      domain.cell[i][j].state = mhd::primitive(UU);
    }
  }
}

void Solver::loopTime(void){
  t = 0.0;
  while(t < tf){
    checkGarbage();
    applyBoundaryConditions();
    loopDomain();
    calcDt();
    advanceTime();
    t += dt;
    std::cout<<t<<"\n";
  }
  domain.write_domain_file();
}


#endif
